\documentclass[../main.tex]{subfiles}

\begin{document}
\section{Justification of the algorithm}
The main idea of the algorithm used to compute the persistent homology is taken from
\cite{campos}. Recall that the homology groups are defined as a quotient of the subgroup
of cycles by the subgroup of boundaries. But we can just as well consider the quotient of the \emph{whole} chain group. More
specifically, consider a filtration \( \set{K^i}_{i = 0}^N \) and its chain
complex, \( C_\ast(K^i) \). We then have the corresponding boundary morphisms,
\begin{equation*}
	\partial_p^i \colon C_p(K^i) \to C_{p-1}(K^i)
\end{equation*}
where the superscript \( i \) refers to the step of the filtration.  refers to the step of
the filtration. The group of \( p \)-cycles is \( \ker{\partial_p^i} \) and the group of
\( p \)-boundaries is \( \im{\partial_{p+1}^i} \). Since \( \partial_p \circ \partial_{p+1}
= 0 \) the boundaries are a subgroup of the cycles, which means the homology groups are
well defined. But the boundaries are a subgroup of \( C_p(K^i) \), which means we can
define what we will call \emph{prehomology groups} by
\begin{equation*}
	P_p(K^i) = C_p(K^i) / \im{\partial_{p+1}^i}
\end{equation*}
which is the result of identifying all homologous chains, not just the cycles. 

Now, because \( \im{\partial_{p+1}^i} \subseteq \ker{\partial_p^i} \), the boundary maps
factor through the prehomology groups, which means the following is well-defined
\begin{align*}
	\hombound{p}{i} \colon P_p(K^i) & \longto P_p(K^j) \\
	[c] & \longmapsto [\partial_p^i c]. 
\end{align*}
In particular,
\begin{equation*}
	\ker{\hombound{p}{i}} = H_p(K^i). 
\end{equation*}



\section{Mutual \( k \)-Nearest Neighbours Graph}
As stated before, the original way of determining clusters in the point cloud was by
finding the maximal cliques of the Mutual \( k \)-Nearest Neighbours graph, \MKNN 
graph for short. We now describe this construction. Given a point cloud, \( C \), its 
Nearest Neighbour directed graph is constructed according to the following
prescription: there is an edge from \( p \) to \( q \) if and only if \( d(p,q) = \min_{r
	\in C} d(p,r) \), so \( q \) is the closest point to \( p \), its \emph{nearest
neighbour}. The reason the graph is directed is because the relation of being a nearest
neighbour is not symmetric, as evidenced by the figure
% TODO: Draw nearest neighbour non example

This generalises to the \( k \)-Nearest Neighbours graph, in which each point is connected
to its \( k \)-th nearest neighbours, that is, the \( k \)-th closest points to it. The
resulting graph is still directed. We obtain the undirected \emph{Mutual} \( k \)-Nearest
Neighbours graph by connecting two points if and only if there are edges between them
in both directions, i.e. if they are \emph{mutual} \( k \)-nearest neighbours. 

The procedure to encode this graph is as follows. First, the distance matrix, \( D \), for
the data set is computed. If we index the points of the cloud by \( C = \set{p_i}_{i =
1}^n \), then this matrix contains the difference between every pair of points:
\begin{equation*}
	D_{ij} = d(p_i, p_j). 
\end{equation*}
This can be done with \textsf{NumPy} and is implemented as a method of the \texttt{Cloud}
class, which models a point cloud. Then, again using \textsf{NumPy}, the indices of each
column of \( D \) are sorted into a new matrix such that the \( i \)-th column of this new
matrix lists the points of \( C \) by increasing order of distance to \( p_i \). In
particular, the first \( k \) are \( p_i \)'s \( k \)-th nearest neighbours. From this we
can then construct the adjacency matrix of the \( k \)NN graph, \( A \), which is in
general not symmetric since the graph is directed. The adjacency matrix of the \MKNN
graph, \( M \), is given by
\begin{equation*}
	M = A \odot A^\top
\end{equation*}
where \( \odot \) denotes the entrywise prodct. Indeed, we have
\begin{equation*}
	M_{ij} = A_{ij}A^\top_{ji} = A_{ij}A_{ji}
\end{equation*}
so that \( M_{ij} \) is nonzero if and only if both \( A_{ij} \) and \( A_{ji} \) are
nonzero, i.e. if there is an edge going from \( p_i \) to \( p_j \) and one from \( p_j	\) to \( p_i \). Furthermore 
\begin{equation*}
	M_{ij} = A_{ij}A_{ji} = A_{ji}A_{ij} = M_{ji}
\end{equation*}
which means that \( M \) is symmetric and therefore the adjacency matrix of an undirected
graph, as we claimed. This adjacency matrix is used to represent the \MKNN graph as a
\textsf{NetworkX} graph. 

\section{Building the filtration}
The work of constructing the filtration is packaged up in the \texttt{Filtration} class.
This class is passed an instance of \texttt{Cloud}. The most straightforward way to
represent a filtration is to simply store an ordered list of the simplices, in this case cliques,
which appear at every step. There are more efficient data structures that can be used, see
% TODO: Afegir refs
, but since the data sets analysed are of small size, this more naive approach sufficed. 

The \textsf{NetworkX} package has methods which can compute every clique in a graph. In a
loop over \( k \) from \( 1 \) to one minus the number of points in the cloud, the
correspoinding \MKNN graph is computed and a list of its cliques is extracted. Of these,
all those which are new and have size at most one more than the ambient dimension ---such
that the simplices they determine have dimension at most the ambient dimension--- are
appended to a list. The \texttt{Simplex} wraps a clique as a list of its points as well as
keeping track of the step, \( k \), at which the clique is born. In addition it implements
methods used in the actual computation of the homology groups.

This list is then sorted by birth, such that cliques born earlier appear firts, and
cliques with the same birth are sorted by increasing size. This guarantees that any
simplex is always preceded by its faces, which is required for later computations. 

\section{Computing the homology}
The classes \texttt{Simplex} and \texttt{Chain} can be used to calculate with the chain
groups. As mentioned before, a \texttt{Simplex} simply wraps a clique as well as its
birth. It also has the property \texttt{faces}, which returns a list of the faces of the
simplex.

The elements of the chain group are linear combinations of simplices (of the same
dimension), but since we are working over \( \F_2 \), this amounts to a list of simplices,
which is what \texttt{Chain} stores. Furthermore, this class implements the addition of
chains which, again because the field we ar working over has characteristic 2, reduces to
taking the symmetric difference of the lists of simplices of the two chains we are adding.
Indeed, if we have two chains of the form \( c_1 = \sum_{i = 1}^{n} \epsilon_i \sigma_i \)
and \( c_2 = \sum_{i = 1}^{n} \delta_i \sigma_i \) with \( \epsilon_i, \delta_i \in \F_2
\), then
\begin{equation*}
	c_1 + c_2 = \sum_{i = 1}^{n} (\epsilon_i + \delta_i) \sigma_i
\end{equation*}
which means the coefficient of \( \sigma_i \) in \( c_1 + c_2 \) is \( \epsilon_j +
\delta_j \). And this will be 1 provided only one of \( \epsilon_j \) or \( \delta_j \) is
equal to 1, and will be 0 whenever \emph{both} \( \epsilon_j \) and \( \delta_j \) are 1
or 0. So \( \sigma_j \) will be present in \( c_1 + c_2 \) whenever it is present in \(
c_1 \) or \( c_2 \), but not both. 

This makes it very easy to implement the boundary morphisms. For a single simplex, wrap
the list of faces inside a \texttt{Chain} object. And for a larger chain, add the
boundaries of each of its constituent simplices. Again, this works because we are taking
coefficients from \( \F_2 \), so that, as explained in 
% TODO: Add reference
the alternating signs that appear in the definition of the boundary all disappear. 

With all of this in place we can 

\end{document}
